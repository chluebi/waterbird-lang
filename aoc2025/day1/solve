map(f, list) {
    new = [];
    for e in list {
        new.push(f(e));
    }
    new
}

filter(p, list) {
    new = [];
    for e in list {
        if p(e) {
            new.push(e);
        }
    }
    new
}

any(p, list) {
    new = [];
    for e in list {
        if p(e) {
            return true;
        }
    }
    return false;
}

fold(step, start, list) {
    if list == [] {
        return start;
    } else {
        return fold(step, step(list[0], start), list[1:]);
    }
}

sum(list) {
    s = 0;
    for x in list {
        s += x;
    }
    s
}

concat(list) {
    s = [];
    for x in list {
        s += x;
    }
    s
}


surroundings_horizontal(inp, y, x, length=1) {
    ret = [];

    dx = -1;
    for dy in range(-1, 2) {
        if y+dy >= 0 && y+dy < len(inp) && x+dx >= 0 && x+dx < len(inp[y+dy]) {
            ret.push(((y+dy), (x+dx)));
        }
    }

    dx = -1;
    for dy in [-1, 1] {
        for dx in range(-1, length) {
            if y+dy >= 0 && y+dy < len(inp) && x+dx >= 0 && x+dx < len(inp[y+dy]) {
                ret.push(((y+dy), (x+dx)));
            }
        }
    }

    dx = length;
    for dy in range(-1, 2) {
        if y+dy >= 0 && y+dy < len(inp) && x+dx >= 0 && x+dx < len(inp[y+dy]) {
            ret.push(((y+dy), (x+dx)));
        }
    }

    return ret;
}


enumerate(list) {
    new_list = [];
    for i in range(len(list)) {
        new_list.push((i, list[i]));
    }
    new_list
}

min(*vals) {
    smallest = vals[0];
    for v in vals[1:] {
        if v < smallest {
            smallest = v;
        }
    }
    smallest
}

max(*vals) {
    largest = vals[0];
    for v in vals[1:] {
        if v > largest {
            largest = v;
        }
    }
    largest
}

binary_search(x, min, max, comp=|x,y|{x-y}, key=|x|{x}) {
    if comp(key(min), x) == 0 {
        return min;
    }

    guess = min + (max - min) / 2;

    
    while true {
        diff = comp(key(guess), x);

        if diff == 0 {
            return guess;
        } else if diff < 0 {
            min = guess + 1;
            if min > max {
                return guess;
            }
        } else {
            max = guess - 1;
            if max < min {
                return guess-1;
            }
        }
        guess = min + (max - min) / 2;
    }
}

binary_search_list(l, x, min, max, comp=|x,y|{x-y}) {
    binary_search(x, min, max, comp=comp, key=|x|{l[x]})
}

sort(l, key=|x|{x}) {

    for i in range(1, len(l)) {
        current_value = l[i];
        current_key = key(current_value);
        j = i - 1;

        min = 0;
        max = j;

        index = binary_search_list(l, current_key, min, max, comp=|x,y|{key(x)-y}) + 1;

        while j >= index {
            l[j+1] = l[j];
            j = j - 1;
        }

        l[j+1] = current_value;
    }
    
    return l;
}



comp_sort(l, key=|x,y|{x-y}) {

    for i in range(1, len(l)) {
        current_value = l[i];
        j = i - 1;

        min = 0;
        max = j;

        index = binary_search_list(l, current_value, min, max, comp=|x,y|{key(x,y)}) + 1;

        while j >= index {
            l[j+1] = l[j];
            j = j - 1;
        }

        l[j+1] = current_value;
    }

    for i in range(1, len(l)) {
        assert(key(l[i-1], l[i]));
    }
    
    return l;
}


pairs(l) {
    ret = [(l[i], l[i+1]) for i in range(0, len(l), 2)];
    ret
}

zip(l1, l2) {
    assert(len(l1) == len(l2));
    [(l1[i], l2[i]) for i in range(len(l1))]
}

sqrt(x) {
    if x == 0 {
        return 0;
    }
    if x == 1 {
        return 1;
    }

    min = 0;
    max = x;
    guess = min + (max - min) / 2;

    while true {
        if guess == x / guess {
            return guess;
        } else if guess < x / guess {
            min = guess + 1;
            if min > max {
                return guess;
            }
        } else {
            max = guess - 1;
            if max < min {
                return guess-1;
            }
        }
        guess = min + (max - min) / 2;
    }
}

sqrt_ceil(x) {
    sq = sqrt(x);
    if sq * sq < x {
        return sq + 1;
    }
    sq
}

join(l, sep="") {
    s = "";
    for i in range(len(l)) {
        s += l[i];
        if i < len(l) - 1 {
            s += sep;
        }
    }
    s
}



part1(inp) {
    for line in inp {
        print(line);
    }
    0
} 


part2(inp) {
    0
} 


main() {
    inp = read("aoc2025/day1/input");
    if inp[-1] == "\n" {
        inp = inp[:-1];
    }
    inp = inp.split("\n");

    (part1(inp), part2(inp))
} 